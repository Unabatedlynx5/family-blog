---
import SocialLayout from '../layouts/SocialLayout.astro';

export const prerender = false;

// Check authentication
const user = Astro.locals.user;
if (!user) {
  return Astro.redirect('/login');
}
---
<SocialLayout title="Family Chat">


    <div class="flex flex-col h-[calc(100vh-140px)] bg-white dark:bg-[#242526] rounded-2xl shadow-lg overflow-hidden font-sans">
      <div class="px-6 py-4 bg-[#f5f5f7]/80 dark:bg-[#242526]/80 backdrop-blur-md border-b border-black/10 dark:border-white/10 font-semibold flex justify-center items-center relative text-black dark:text-white">
        <span class="text-lg">Family Chat</span>
        <span id="connection-status" class="text-xs text-[#8e8e93] dark:text-[#b0b3b8] absolute right-6">Connecting...</span>
      </div>
      
      <div id="messages" class="flex-1 overflow-y-auto px-6 py-4 flex flex-col gap-2 bg-[#f5f5f7] dark:bg-[#1c1c1e]">
        <!-- Messages will be injected here -->
      </div>
      
      <!-- Hidden config to pass server-side user data to client client script -->
      <div id="chat-config" data-user-id={user.sub} data-user-name={user.name} data-user-email={user.email} style="display:none;"></div>

      <div class="p-4 bg-white dark:bg-[#242526] border-t border-black/10 dark:border-white/10 flex items-end gap-3">
        <button class="p-2 rounded-full text-[#007aff] dark:text-[#0a84ff] bg-transparent border-none cursor-pointer hover:bg-black/5 dark:hover:bg-white/10 transition-colors">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
        </button>
        <div class="flex-1 relative">
            <textarea id="message-input" rows="1" placeholder="iMessage" class="w-full bg-white dark:bg-[#3a3b3c] border border-[#c6c6c8] dark:border-[#3e4042] rounded-2xl px-4 py-2 text-base leading-normal max-h-32 resize-none focus:outline-none focus:border-[#007aff] dark:focus:border-[#0a84ff] text-black dark:text-[#e4e6eb]"></textarea>
        </div>
        <button id="send-btn" class="p-2 rounded-full bg-[#007aff] dark:bg-[#0a84ff] text-white border-none cursor-pointer hover:bg-[#0063cc] dark:hover:bg-[#0071e3] transition-colors flex items-center justify-center w-9 h-9">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
        </button>
      </div>
    </div>

    <script>
      // Connect to WebSocket
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const host = window.location.host;
      const wsUrl = `${protocol}//${host}/api/chat/connect`;
      
      let ws: WebSocket;
      const messagesContainer = document.getElementById('messages') as HTMLDivElement;
      const statusDiv = document.getElementById('connection-status') as HTMLSpanElement;
      const input = document.getElementById('message-input') as HTMLTextAreaElement;
      const sendBtn = document.getElementById('send-btn') as HTMLButtonElement;
      const config = document.getElementById('chat-config');
      
      // Get user info from server-injected config
      const userId = config?.dataset.userId || 'anon';
      const userName = config?.dataset.userName || 'Anonymous';
      const userEmail = config?.dataset.userEmail || '';

      async function fetchHistory() {
        try {
          const res = await fetch('/api/chat/messages');
          if (res.ok) {
            const data = await res.json() as { messages: any[] };
            if (Array.isArray(data.messages)) {
              messagesContainer.innerHTML = '';
              data.messages.forEach(appendMessage);
            }
          }
        } catch (e) {
          console.error('Failed to fetch history', e);
        }
      }

      let retryDelay = 1000;
      const maxDelay = 30000;

      function connect() {
        if (statusDiv) statusDiv.textContent = 'Connecting...';
        ws = new WebSocket(wsUrl);
        
        ws.onopen = () => {
          if (statusDiv) {
            statusDiv.textContent = 'Connected';
            statusDiv.style.color = 'green';
          }
          retryDelay = 1000; // Reset delay on successful connection
        };
        
        ws.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            if (data.type === 'message') {
              appendMessage(data.message);
            }
          } catch (e) {}
        };
        
        ws.onclose = () => {
          if (statusDiv) {
            statusDiv.textContent = `Disconnected. Reconnecting in ${retryDelay/1000}s...`;
            statusDiv.style.color = 'red';
          }
          setTimeout(connect, retryDelay);
          retryDelay = Math.min(retryDelay * 2, maxDelay); // Exponential backoff
        };
      }
      
      function appendMessage(msg: any) {
        if (!messagesContainer) return;
        const div = document.createElement('div');
        // Check both user_id (from server) and userId (from session)
        const isOwn = msg.user_id === userId;
        
        // Tailwind classes for message bubbles
        // iMessage style:
        // Own: bg-blue-500 text-white rounded-2xl rounded-br-none ml-auto max-w-[70%]
        // Others: bg-gray-200 text-black rounded-2xl rounded-bl-none mr-auto max-w-[70%]
        
        div.className = `flex flex-col ${isOwn ? 'items-end' : 'items-start'} mb-2`;
        
        const displayName = msg.user || msg.user_id || 'Anon';
        
        const bubbleClass = isOwn 
            ? 'bg-[#007aff] dark:bg-[#0a84ff] text-white rounded-[18px] rounded-br-sm px-3 py-2 max-w-[75%] relative' 
            : 'bg-[#e5e5ea] dark:bg-[#3a3b3c] text-black dark:text-[#e4e6eb] rounded-[18px] rounded-bl-sm px-3 py-2 max-w-[75%] relative';

        div.innerHTML = `
          ${!isOwn ? `<div class="text-[10px] text-[#8e8e93] dark:text-[#b0b3b8] ml-3 mb-1">${displayName}</div>` : ''}
          <div class="${bubbleClass}">
            <div class="text-[15px] leading-snug break-words">${msg.text}</div>
          </div>
        `;
        messagesContainer.appendChild(div);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }
      
      function sendMessage() {
        if (!input) return;
        const text = input.value.trim();
        if (text && ws && ws.readyState === WebSocket.OPEN) {
          // Get user info from session storage (set during login)
          // If not set, we might need to fetch it or default to 'Anonymous'
          // Ideally, the server should validate the user from the token, but for this simple chat
          // we are passing it in the message for display.
          // A more secure way: Authenticate the WebSocket connection with the token, 
          // and let the server determine the user ID/Name.
          // For now, let's send what we have.

          ws.send(JSON.stringify({ 
              type: 'message', 
              text,
              userId,
              user: userName,
              email: userEmail
          }));
          input.value = '';
        }
      }
      
      if (sendBtn) {
        sendBtn.addEventListener('click', () => {
          sendMessage();
        });
      }
      
      if (input) {
        input.addEventListener('keypress', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            if (sendBtn) sendBtn.click();
          }
        });
      }
      
      fetchHistory();
      connect();
    </script>
</SocialLayout>
