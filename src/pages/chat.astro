---
import SocialLayout from '../layouts/SocialLayout.astro';

export const prerender = false;

// Check authentication
const user = Astro.locals.user;
if (!user) {
  return Astro.redirect('/login');
}
---
<SocialLayout title="Family Chat">


    <div class="flex flex-col h-[calc(100vh-140px)] bg-white dark:bg-[#242526] rounded-2xl shadow-lg overflow-hidden font-sans">
      <div class="px-6 py-4 bg-[#f5f5f7]/80 dark:bg-[#242526]/80 backdrop-blur-md border-b border-black/10 dark:border-white/10 font-semibold flex justify-center items-center relative text-black dark:text-white">
        <span class="text-lg">Family Chat</span>
        <span id="connection-status" class="text-xs text-[#8e8e93] dark:text-[#b0b3b8] absolute right-6">Connecting...</span>
        <span id="online-count" class="text-xs text-[#8e8e93] dark:text-[#b0b3b8] absolute left-6">Online: â€”</span>
      </div>
      
      <div id="messages" class="flex-1 overflow-y-auto px-6 py-4 flex flex-col gap-2 bg-[#f5f5f7] dark:bg-[#1c1c1e]">
        <!-- Messages will be injected here -->
      </div>
      
      <!-- Hidden config to pass server-side user data to client client script -->
      <div id="chat-config" data-user-id={user.sub} data-user-name={user.name} data-user-email={user.email} style="display:none;"></div>

      <div class="p-4 bg-white dark:bg-[#242526] border-t border-black/10 dark:border-white/10 flex items-end gap-3">
        <button class="p-2 rounded-full text-[#007aff] dark:text-[#0a84ff] bg-transparent border-none cursor-pointer hover:bg-black/5 dark:hover:bg-white/10 transition-colors">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
        </button>
        <div class="flex-1 relative">
            <textarea id="message-input" rows="1" placeholder="iMessage" class="w-full bg-white dark:bg-[#3a3b3c] border border-[#c6c6c8] dark:border-[#3e4042] rounded-2xl px-4 py-2 text-base leading-normal max-h-32 resize-none focus:outline-none focus:border-[#007aff] dark:focus:border-[#0a84ff] text-black dark:text-[#e4e6eb]"></textarea>
        </div>
        <button id="send-btn" class="p-2 rounded-full bg-[#007aff] dark:bg-[#0a84ff] text-white border-none cursor-pointer hover:bg-[#0063cc] dark:hover:bg-[#0071e3] transition-colors flex items-center justify-center w-9 h-9">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
        </button>
      </div>
    </div>

    <script>
      // Connect to WebSocket
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const host = window.location.host;
      const wsUrl = `${protocol}//${host}/api/chat/connect`;
      
      let ws: WebSocket;
      const messagesContainer = document.getElementById('messages') as HTMLDivElement;
      const statusDiv = document.getElementById('connection-status') as HTMLSpanElement;
      const input = document.getElementById('message-input') as HTMLTextAreaElement;
      const sendBtn = document.getElementById('send-btn') as HTMLButtonElement;
      const config = document.getElementById('chat-config');
      
      // Get user info from server-injected config
      const userId = config?.dataset.userId || 'anon';
      const userName = config?.dataset.userName || 'Anonymous';
      const userEmail = config?.dataset.userEmail || '';

      async function fetchHistory() {
        try {
          const res = await fetch('/api/chat/messages');
          if (res.ok) {
            const data = await res.json() as { messages: any[] };
            if (Array.isArray(data.messages)) {
              messagesContainer.innerHTML = '';
              data.messages.forEach(appendMessage);
            }
          }
        } catch (e) {
          console.error('Failed to fetch history', e);
        }
      }

      let retryDelay = 1000;
      const maxDelay = 30000;

      // Presence heartbeat: ping server every 30s to update last_seen
      const PRESENCE_INTERVAL = 30 * 1000;

      function connect() {
        if (statusDiv) statusDiv.textContent = 'Connecting...';
        ws = new WebSocket(wsUrl);
        
        ws.onopen = () => {
          if (statusDiv) {
            statusDiv.textContent = 'Connected';
            statusDiv.style.color = 'green';
          }
          retryDelay = 1000; // Reset delay on successful connection
          // Update presence immediately on open
          updatePresence();
        };
        
        ws.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            if (data.type === 'message') {
              appendMessage(data.message || data); // Handle both wrapped and unwrapped format
            }
          } catch (e) {}
        };
        
        ws.onclose = () => {
          if (statusDiv) {
            statusDiv.textContent = `Disconnected. Reconnecting in ${retryDelay/1000}s...`;
            statusDiv.style.color = 'red';
          }
          setTimeout(connect, retryDelay);
          retryDelay = Math.min(retryDelay * 2, maxDelay); // Exponential backoff
        };
      }
      
      function appendMessage(msg: any) {
        if (!messagesContainer) return;
        const div = document.createElement('div');
        // Check both user_id (from server) and userId (from session)
        const isOwn = msg.user_id === userId || msg.userId === userId;
        
        div.className = `flex ${isOwn ? 'flex-row-reverse' : 'flex-row'} items-end gap-2 mb-4`;
        
        const displayName = msg.user || msg.user_id || msg.name || 'Anon';
        const avatarUrl = msg.avatar_url || msg.avatar || msg.picture || `https://ui-avatars.com/api/?name=${encodeURIComponent(displayName)}&background=random`;
        
        const bubbleClass = isOwn 
            ? 'bg-[#007aff] dark:bg-[#0a84ff] text-white rounded-[18px] rounded-br-sm px-3 py-2 relative text-left' 
            : 'bg-[#e5e5ea] dark:bg-[#3a3b3c] text-black dark:text-[#e4e6eb] rounded-[18px] rounded-bl-sm px-3 py-2 relative text-left';

        div.innerHTML = `
          <img src="${avatarUrl}" class="w-8 h-8 rounded-full object-cover mb-1 shadow-sm border border-black/5 dark:border-white/10 bg-gray-100 dark:bg-gray-800" alt="${displayName}" />
          <div class="flex flex-col ${isOwn ? 'items-end' : 'items-start'} max-w-[70%]">
             ${!isOwn ? `<div class="text-[11px] text-[#8e8e93] dark:text-[#b0b3b8] ml-1 mb-1">${displayName}</div>` : ''}
             <div class="${bubbleClass}">
               <div class="text-[15px] leading-snug break-words whitespace-pre-wrap">${msg.text}</div>
             </div>
          </div>
        `;
        messagesContainer.appendChild(div);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }
      
      function sendMessage() {
        if (!input) return;
        const text = input.value.trim();
        if (text && ws && ws.readyState === WebSocket.OPEN) {
          // User info is now attached to the connection on the server side
          // Only send the text content as requested by GlobalChat
          ws.send(JSON.stringify({ 
              type: 'message', 
              text
          }));
          input.value = '';
        }
      }

      let presenceTimer: number | null = null;
      async function updatePresence(){
        try{
          await fetch('/api/chat/presence', { method: 'POST' });
        }catch(e){/* ignore */}
      }

      async function fetchOnlineCount(){
        try{
          const res = await fetch('/api/members');
          if (res.ok){
            const data = await res.json() as { active: number };
            const count = (data.active || 0);
            const el = document.getElementById('online-count');
            if (el) el.textContent = `Online: ${count}`;
          }
        }catch(e){/* ignore */}
      }
      
      if (sendBtn) {
        sendBtn.addEventListener('click', () => {
          sendMessage();
        });
      }
      
      if (input) {
        input.addEventListener('keypress', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            if (sendBtn) sendBtn.click();
          }
        });
      }
      
      fetchHistory();
      connect();
      // Start presence heartbeat and online count refresh
      presenceTimer = window.setInterval(()=>{ updatePresence(); fetchOnlineCount(); }, PRESENCE_INTERVAL);
      // Also fetch online count immediately
      fetchOnlineCount();
    </script>
</SocialLayout>
