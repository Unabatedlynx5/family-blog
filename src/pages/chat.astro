---
import SocialLayout from '../layouts/SocialLayout.astro';

export const prerender = false;

// Check authentication
const token = Astro.cookies.get('accessToken')?.value;
if (!token) {
  return Astro.redirect('/login');
}
---
<SocialLayout title="Family Chat">


    <div class="flex flex-col h-[calc(100vh-140px)] bg-white rounded-2xl shadow-lg overflow-hidden font-sans">
      <div class="px-6 py-4 bg-[#f5f5f7]/80 backdrop-blur-md border-b border-black/10 font-semibold flex justify-center items-center relative text-black">
        <span class="text-lg">Family Chat</span>
        <span id="connection-status" class="text-xs text-[#8e8e93] absolute right-6">Connecting...</span>
      </div>
      
      <div id="messages" class="flex-1 overflow-y-auto px-6 py-4 flex flex-col gap-2 bg-[#f5f5f7]">
        <!-- Messages will be injected here -->
      </div>
      
      <div class="p-4 bg-white border-t border-black/10 flex items-end gap-3">
        <button class="p-2 rounded-full text-[#007aff] bg-transparent border-none cursor-pointer hover:bg-black/5 transition-colors">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
        </button>
        <div class="flex-1 relative">
            <textarea id="message-input" rows="1" placeholder="iMessage" class="w-full bg-white border border-[#c6c6c8] rounded-2xl px-4 py-2 text-base leading-normal max-h-32 resize-none focus:outline-none focus:border-[#007aff]"></textarea>
        </div>
        <button id="send-btn" class="p-2 rounded-full bg-[#007aff] text-white border-none cursor-pointer hover:bg-[#0063cc] transition-colors flex items-center justify-center w-9 h-9">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
        </button>
      </div>
    </div>

    <script>
      // Connect to WebSocket
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const host = window.location.host;
      const wsUrl = `${protocol}//${host}/api/chat/connect`;
      
      let ws: WebSocket;
      const messagesContainer = document.getElementById('messages') as HTMLDivElement;
      const statusDiv = document.getElementById('connection-status') as HTMLSpanElement;
      const input = document.getElementById('message-input') as HTMLTextAreaElement;
      const sendBtn = document.getElementById('send-btn') as HTMLButtonElement;
      
      // Get user info from session storage or token
      const token = sessionStorage.getItem('accessToken');
      let userId = sessionStorage.getItem('userId');
      
      if (!userId && token) {
        try {
          const payload = JSON.parse(atob(token.split('.')[1]));
          userId = payload.sub;
        } catch (e) {}
      }
      userId = userId || 'anon';

      function connect() {
        if (statusDiv) statusDiv.textContent = 'Connecting...';
        ws = new WebSocket(wsUrl);
        
        ws.onopen = () => {
          if (statusDiv) {
            statusDiv.textContent = 'Connected';
            statusDiv.style.color = 'green';
          }
          // Send auth message if needed, or just rely on cookie if the connect endpoint handles it
          // The current GlobalChat implementation expects a message with user_id
          ws.send(JSON.stringify({ type: 'auth', token }));
        };
        
        ws.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            if (data.type === 'message') {
              appendMessage(data.message);
            } else if (data.type === 'history') {
                // Clear existing messages first if needed, or just append
                // messagesContainer.innerHTML = ''; 
                // Actually, let's just append them.
                if (Array.isArray(data.messages)) {
                    data.messages.forEach(appendMessage);
                }
            }
          } catch (e) {}
        };
        
        ws.onclose = () => {
          if (statusDiv) {
            statusDiv.textContent = 'Disconnected. Reconnecting...';
            statusDiv.style.color = 'red';
          }
          setTimeout(connect, 3000);
        };
      }
      
      function appendMessage(msg: any) {
        if (!messagesContainer) return;
        const div = document.createElement('div');
        // Check both user_id (from server) and userId (from session)
        const isOwn = msg.user_id === userId;
        
        // Tailwind classes for message bubbles
        // iMessage style:
        // Own: bg-blue-500 text-white rounded-2xl rounded-br-none ml-auto max-w-[70%]
        // Others: bg-gray-200 text-black rounded-2xl rounded-bl-none mr-auto max-w-[70%]
        
        div.className = `flex flex-col ${isOwn ? 'items-end' : 'items-start'} mb-2`;
        
        const displayName = msg.user || msg.user_id || 'Anon';
        
        const bubbleClass = isOwn 
            ? 'bg-[#007aff] text-white rounded-[18px] rounded-br-sm px-3 py-2 max-w-[75%] relative' 
            : 'bg-[#e5e5ea] text-black rounded-[18px] rounded-bl-sm px-3 py-2 max-w-[75%] relative';

        div.innerHTML = `
          ${!isOwn ? `<div class="text-[10px] text-[#8e8e93] ml-3 mb-1">${displayName}</div>` : ''}
          <div class="${bubbleClass}">
            <div class="text-[15px] leading-snug break-words">${msg.text}</div>
          </div>
        `;
        messagesContainer.appendChild(div);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }
      
      function sendMessage() {
        if (!input) return;
        const text = input.value.trim();
        if (text && ws && ws.readyState === WebSocket.OPEN) {
          // Get user info from session storage (set during login)
          // If not set, we might need to fetch it or default to 'Anonymous'
          // Ideally, the server should validate the user from the token, but for this simple chat
          // we are passing it in the message for display.
          // A more secure way: Authenticate the WebSocket connection with the token, 
          // and let the server determine the user ID/Name.
          // For now, let's send what we have.
          const userId = sessionStorage.getItem('userId') || 'anon';
          // We don't have the user's name stored in session storage yet, let's add it to login.astro or fetch it.
          // For now, let's default to 'Me' or 'User'.
          // Actually, let's update login.astro to store 'userName' as well.
          const userName = sessionStorage.getItem('userName') || 'Family Member';

          ws.send(JSON.stringify({ 
              type: 'message', 
              text,
              userId,
              user: userName
          }));
          input.value = '';
        }
      }
      
      if (sendBtn) {
        sendBtn.addEventListener('click', () => {
          sendMessage();
        });
      }
      
      if (input) {
        input.addEventListener('keypress', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            if (sendBtn) sendBtn.click();
          }
        });
      }
      
      connect();
    </script>
</SocialLayout>
